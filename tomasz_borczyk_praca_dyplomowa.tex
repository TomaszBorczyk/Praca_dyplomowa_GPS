%Przykładowy plik ułatwiający złożenie projektu dyplomowego inżynierskiego.
%UWAGA: Generowany napis na stronie tytułowej o treści PROJEKT DYPLOMOWY INŻYNIERSKI został zaproponowany przeze mnie i nie jest, póki co, potwierdzony przez władze wydziału. Przed ostatecznym oddaniem tak złożonej pracy należy upewnić się jaka powinna być treść tego napisu. W momencie gdy uzyskam informację na temat treści tego napisu, dokonam niezbędnych zmian w źródłach.

\documentclass[eng,printmode]{mgr}
%opcje klasy dokumentu mgr.cls zostały opisane w dołączonej instrukcji

%poniżej deklaracje użycia pakietów, usunąć to co jest niepotrzebne
\usepackage{polski} %przydatne podczas składania dokumentów w j. polskim
%\usepackage[polish]{babel}%alternatywnie do pakietu polski, wybrać jeden z nich
\usepackage[utf8]{inputenc} %kodowanie znaków, zależne od systemu
\usepackage[T1]{fontenc} %poprawne składanie polskich czcionek

\usepackage{url}
%pakiety do grafiki
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage{subfigure}
\usepackage{psfrag}

%pakiety dodające dużo dodatkowych poleceń matematycznych
\usepackage{amsmath}
\usepackage{amsfonts}

%pakiety wspomagające i poprawiające składanie tabel
\usepackage{supertabular}
\usepackage{array}
\usepackage{tabularx}
\usepackage{hhline}

\usepackage{listings}

%pakiet wypisujący na marginesie etykiety równań i rysunków zdefiniowanych przez \label{}, chcąc wygenerować finalną wersję dokumentu wystarczy usunąć poniższą linię
\usepackage{showlabels}

%definicje własnych poleceń
\newcommand{\R}{I\!\!R} %symbol liczb rzeczywistych, działa tylko w trybie matematycznym
\newtheorem{theorem}{Twierdzenie}[section] %nowe otoczenie do składania twierdzeń

%dane do złożenia strony tytułowej
\title{System antykradzieżowy kół samochodowych}
\engtitle{Car wheels anti-theft framework}
\author{Tomasz Borczyk}
\supervisor{dr inż. Łukasz Jeleń}
%\guardian{dr hab. inż. Imię Nazwisko Prof. PWr, I-6} %nie używać jeśli opiekun jest tą samą osobą co prowadzący pracę
\field{Automatyka i Robotyka (AIR)}
\specialisation{Technologie informacyjne w systemach automatyki (ART)}

\begin{document}
\bibliographystyle{plabbrv} %tylko gdy używamy BibTeXa, ustawia polski styl bibliografii
\maketitle %polecenie generujące stronę tytułową
\tableofcontents


\chapter{Wstęp}
Wykorzystanie systemu GPS jest obecnie powszechnie stosowane do nawigacji w każdego rodzaju transporcie. Istnieje również inna, mniej powszechna grupa zastosowania mająca na celu lokalizację przedmiotów, często osobistych. Niektóre z lokalizatorów, takie jak TrackR \cite{TrackR}, wykorzystują łączność Bluetooth, co pozwala na miniaturyzację urządzenia oraz jego niskie zużycie energii. Niestety tego typu rozwiązanie działa tylko na niewielkie odległości od urządzenia, co wymaga budowania ogromnej sieci użytkowników w celu pokrycia dużej powierzchni, co jest praktycznie niemożliwe. Zaproponowane w pracy rozwiązanie wykorzystuje lokalizację GPS i łączność z internetem. Tego typu rozwiązanie mogą służyć do monitorowania położenia roweru, torebki/plecaka, dziecka, psa, samochodu czy też tytułowych kół samochodowych. Urządzenie w połączeniu z obsługującą je aplikacją służyłoby do odnajdywania zgub, a potencjalnie skradzionych przedmiotów. Praca ta prezentuje implementację tego rodzaju uniwersalnego systemu, który pozwoli użytkownikowi monitorować i zarządzać posiadanymi urządzeniami. Aplikacja webowa stworzona jest w w stosie technologicznym \textit{MEAN} (MongoDB, Express, Angular, Node.js).

\section{Cel pracy}
Celem pracy jest stworzenie uniwersalnego systemu pozwalającego na lokalizację urządzenia GPS, w tym:
\begin{itemize}
\item integrację i oprogramowanie nadajnika GPS złożonego z płytki Adafruit i funkcjonalnych modułów,
\item serwer w Node.js obsługującego przepływ danych i zapis danych w bazie danych MongoDB,
\item aplikację webową stworzoną w Angular 4,
\item aplikację mobilną stworzoną w Ionic.
\end{itemize}
Tak stworzony system będzie został uruchomiony i wdrożony na zewnętrzne serwery.

\section{Zakres pracy}
Praca dzieli się na dwie części. W części teoretycznej opisane są:
\begin{itemize}
\item moduły elektroniczne,
\item biblioteki,
\item platformy programistyczne,
\item narzędzia pomocnicze.
\end{itemize}
Część inżynierska zajmuje się opisem implementacji funkcjonalności, procesem wykonanych prac i oprogramowaniem.

\chapter{Część teoretyczna}
W części tej uwaga będzie poświęcona technologiom i poszczególnym elementom, które zostały wykorzystane w trakcie projektu. 

\section{Płytka Adafruit i moduły funkcjonalne}
Do zbudowania urządzenia monitorującego lokalizację użyto gotowe moduły bazujące na systemie Arduino. Przy wyborze elementów kierowano się głównie ich wielkością. Urządzenie traktowane jest jako prototyp - znacznie najlepsze wyniki w wielkości można by osiągnąć projektując płytkę samodzielnie i używając tylko niezbędnych elementów i złącz.

Wykorzystane zostały:
\begin{itemize}
\item Adafruit Feather 32u4 FONA,
\item moduł UART GPS NEO-6M z wbudowaną anteną,
\item czujnik wychylenia / wstrząsów firmy Waveshare,
\item akumulator litowo-polimerowy 1S 500mAh.
\item zewnętrzna antena na złącze U.FL
\end{itemize}

Główna płytka to Adafruit Feather 32u4 FONA. Wyposażona jest w mikrokontroler Atmega 32u4 oraz moduł GSM z wejściem na kartę SIM. Posiada wejścia microUSB, służące do programowania oraz zasilania płytki w trakcie debugowania, oraz zasilania dla akumulatora Li-Pol, który jest niezbędny do pracy z modułem GSM oraz zasilania układu w pracy zdalnej. Posiada piny do komunikacji po UART, co pozwala na prostą obsługę modułu GPS poprzez Serial port.

Moduł GPS wyposażony jest w interfejs UART, za pomocą którego następuje przesył danych. Po dostarczeniu zasilania 2,7V-5,0V automatycznie rozpocznie próby nawiązania połączenia z satelitami. W zależności od otoczenia i warunków pogodowych pierwsza połączenie może trwać od 1 do kilku minut. Po skutecznym połączeniu moduł rozpocznie wysyłanie danych NMEA. Dane te składają się ze zdań reprezentowanych przez początkowe słowo, które określa ich typ. Każde ze zdań zawiera pewien zestaw informacji, takie jak położenie, prędkość, dane satelitarne, status i inne dane wykorzystywane w transporcie morskim i powietrznym. Informacje powtarzają się między zdaniami, ale każdy zestaw jest unikalny \cite{nmea}.

Czujnik wychylenia jest bardzo prostym układem, który poza pinami zasilania posiada pin wyjściowy podający napięcie w przypadku odpowiedniego ruchu modułu.

\begin{figure}

\begin{center}
    \begin{tabular}{ | p{2cm} | p{13cm} |}
    \hline
    Message & Description \\ \hline
    GGA & Time, position and fix type data \\
    GLL & Latitude, longitude\\
    UTC & time of position fix and status \\
    GSA & GPS receiver operating mode, satellites used in the position solution, and DOP values \\
    GSV & Number of GPS satellites in view satellite ID numbers, elevation, azimuth, SNR values \\
    MSS & Signal-to-noise ratio, signal strength, frequency, and bit rate from a radio-beacon receiver \\
    RMC & Time, date, position, course and speed data \\
    VTG & Course and speed information relative to the ground \\
    ZDA & PPS timing message (synchronized to PPS) \\

    \hline
    \end{tabular}
    \end{center}
	\caption{Tabela przykładowych formatów NMEA \cite{nmea_table}}
\end{figure}

\begin{figure}
\begin{lstlisting}[breaklines]
  $GPRMC,030428.00,A,2232.73995,N,11404.60275,E,0.037,,070314,,,A*7E
\end{lstlisting}
\caption{Przykładowe zdanie GPRMC, \textit{Recommended Minimum}}
\end{figure}

\section{OpenSCAD}
OpenSCAD to oprogramowanie pozwalające na projektowanie obiektów technicznych w 3D, które pozwala na ich opisywanie w sposób programistyczny. Kompilator interpretuje skrypt i na jego podstawie generowany jest model 3D. Dzięki wykorzystaniu zmiennych i funkcji, projekty są w łatwy sposób skalowalne a parametry modyfikowalne. Modelowanie polega w głównej mierze na wykorzystywaniu podstawowych operacji na bryłach do tworzenia złożonych obiektów. Przykładami takich operacji są: \textit{rotate, translate, scale, union, difference} \cite{openscad}.

Program ten został wykorzystany do zaprojektowania obudowy nadajnika i późniejszego wytworzenia na drukarce 3D.


\section{Node.js}
Jako technologię wykorzystaną do napisania strony serwerowej aplikacji wykorzystano Node.js. Wybór narzędzia był kierowany możliwością łatwej implementacji serwera API, który był naturalnym wyborem w przypadku komunikacji różnych platform klienckich z serwerem - jeden kod serwerowy obsługuje połączenia o różnych źródłach.

Sam Node.js jestt dynamicznie rozwijanym i chętnie w ostatnich czasach używanym środowiskiem uruchomieniowym open-source opartym na JavaScripcie. Udostępnia ono narzędzia do tworzenia aplikacji sieciowych: od uruchamiania skryptów po stronie serwera, do obsługiwania aplikacji internetowych. Charakterystyczną cechą Node.js jest asynchroniczność: wykonywanie operacji takich jak wczytywanie plików lub obsługa zapytań do bazy danych nie blokuje dalszego kodu przed wykonaniem. Dzięki temu czas, który w przypadku działania synchronicznego byłby stracony na wykonywanie danej operacji blokującej, jest zwalniany i możliwy do obsługi innych zapytań \cite{nodejs_blocking}.

Dużym atutem korzystania z Node.js jest dostęp do npm, czyli menadżera paczek tworzonych przez społeczność. Jest to oprogramowanie o podobnej funkcjonalności co NuGet Package Manager dla .NET, RubyGem dla Ruby czy też pip dla Python. Paczki dostępne w npm to biblioteki, rozszerzenia a nawet całe frameworki. Obecnie npm posiada największą ze wszystkich menadżerów ilość paczek, których obecnie jest dostępnych ponad pół miliona \cite{module_counts}.

\subsection{Express.js}
Express.js to najczęściej pobierana paczka z npm - ponad 160 milionów pobrań (stan na 8 czerwca 2017) \cite{express_popularity}. Jest to framework dostarczający narzędzi do budowania aplikacji internetowych. Udostępnia takie funkcjonalności jak:
\begin{itemize}
\item obsługa routingu aplikacji do łatwego tworzenia API,
\item funkcje middleware.
\end{itemize}

Poniższy przykład przedstawia stworzenie bazowego routingu:
\begin{lstlisting}{javascript}
app.get('/user', (req, res) => res.send('John Doe'));
\end{lstlisting}
Użytkownik po wysłaniu zapytania HTTP GET na dany adres, otrzyma w odpowiedzi nazwę 'John Doe'. Zmienna \textit{req} to obiekt który przechowuje dane o zapytaniu (nagłówki, treść, adres), a \textit{res} służy do wysłania odpowiedzi.

Wykorzystanie middleware:
\begin{lstlisting}{javascript}
router.get('/user', isLoggedIn, sendUser);

isLoggedIn = (req, res, next) => {
	if(req.loggedIn) {
		next();
	} else {
		res.send('not authenticated');
	}
};

sendUser = (req, res) => res.send('John Doe');
\end{lstlisting}
W powyższym przykładzie funkcja isLoggedIn pełni rolę middleware, czyli pośredniczącej metody będącej kolejnym krokiem w pewnym procesie routingu, w tym przypadku dostępu do danych użytkownika. Wywołanie funkcji \textit{next()} powoduje przejście do kolejnej funkcji w cyklu (w przykładzie jest to \textit{sendUser}).
%tutaj mógłby znaleźć się obrazek obrazujący middleware
\subsection{Inne biblioteki}
Inne warte uwagi biblioteki wykorzystane w projekcie:
\begin{itemize}
\item Passport.js
\item Mongoose
\item Socket.io
\end{itemize}
Passport.js to biblioteka implementująca autentykację użytkowników, dedykowana dla aplikacji opartych o Express.js. Jest sprawdzonym rozwiązaniem bardzo ważnej części oprogramowania, jakim jest bezpieczeństwo logowania i przebieg autoryzacji. Przy pomocy tej biblioteki możliwa jest implementacja logowania się przez strony społecznościowe (Facebook, Google, Twitter) a także tradycyjnie przez email i hasło. 

Mongoose to biblioteka usprawniająca pracę z MongoDB. Baza ta jest elastyczna i nie wprowadza struktur encji w tradycyjnym kontekście baz danych. Jest to duży atut, jednak komplikuje to pracę na modelach z punktu widzenia programisty. Mongoose rozwiązuje ten problem dzięki możliwości tworzenia obiektów o zdefiniowanych polach i ich typach.

Socket.io, wykorzystujący m.in. WebSocket (protokół bazujący na połączeniu TCP), pozwala na dwukierunkową komunikację w czasie rzeczywistym. W rezultacie serwer może wysyłać informacje stronie klienckiej, co w przypadku zapytań HTTP jest niemożliwe bez uprzedniej interakcji klienta. W pracy biblioteka ta jest wykorzystywana do tworzenia powiadomień o niepożądanym ruchu urządzenia GPS.

\section{MongoDB}
Baza danych MongoDB jest nierelacyjną bazą danych (NoSQL) popularnie wykorzystywaną w przypadku serwerów zbudowanych na Node.js i Express. Dokumenty w bazie danych przechowywane są w postaci obiektów JSON, dzięki czemu JavaScript natywnie je obsługuje bez potrzeby dodatkowej obróbki danych. Wyszukiwania i pracowanie na danych jest bardzo szybkie, jednak pozbawione tradycyjnych zapytań SQL.
\section{Angular 4}
Jako narzędzie do stworzenia klienckiej strony aplikacji webowej został wybrany Angular 4. Jest to popularny framework pozwalający na tworzenie tzw. \textit{single page applications} - aplikacji webowych, w których nie występuje efekt przekierowań i przeładowywania strony, a dane zmieniają się automatycznie. Logika aplikacji pisana jest w TypeScript - języku stworzonym przez Microsoft, opartym na JavaScript i wprowadzającym takie funkcjonalności jak typowanie statyczne, klasy i interfejsy. TypeScript wciąż jest transpilowany do czystego JavaScript w celu możliwości uruchomienia przez przeglądarki internetowe, a więc zaletą tego języka jest przede wszystkim wygoda programowania i możliwość wykrywania błędów na poziomie kompilacji.

Angular odznacza się modularnością w tworzeniu aplikacji. Opiera się on na tworzeniu komponentów będących poszczególnymi częściami aplikacji. Komponent steruje poszczególnym widokiem (będącym szablonem HTML), między którym zachodzi zwykle \textit{two-way data binding} - mechanizm pozwalający dynamicznie, w czasie rzeczywistym uaktualniać dane w momencie ich zmiany w szablonie HTML lub komponencie TypeScript.
\section{Ionic}
W ramach projektu specjalnościowego powstała także aplikacja mobilna stworzona za pomocą Ionic. Wybór narzędzia wynika z wykorzystania Angulara przez Ionic, co pozwala na wysoką reużywalność kodu i proste dostosowanie aplikacji do wymagań aplikacji na telefon.
\section{Narzędzia}
W trakcie tworzenia pracy wykorzystywane zostały różne narzędzia pomocnicze ułatwiające projektowanie, ale mające także wpływ na proces ciągłej integracji\cite{CI}. Ze względu na jednoosobowy charakter pracy proces ten był mocno uproszczony, jednak korzystano z repozytorium, automatyzacji budowania aplikacji webowej oraz automatycznego wdrażanie jej na zewnętrzny serwer.
\subsection{GIT}
\subsection{Travis}
Jest to narzędzie pozwalające na automatyczne budowanie i testowanie aplikacji na dedykowanym serwerze. Proces ten uruchamia się w momencie aktualizacji repozytorium GIT. Wykonywane operacje są opisane w skrypcie umieszczonym wewnątrz każdego projektu. W ramach procesu możliwe jest wdrożenie aplikacji na zewnętrzny serwer.
\subsection{Inne}
Jako platformę serwerową wykorzystano Heroku\cite{heroku}, która pozwala na szybkie i bezproblemowe wdrażanie i uruchamianie aplikacji. Aby zachować ciągłość procesu i umożliwić Heroku otrzymywanie danych z serwerów Travis, potrzebne jest wygenerowanie unikatowego klucza aplikacji za pomocą Heroku CLI\cite{heroku_cli} i dodanie go do skryptu Travis.

Baza danych została założona na serwisie mLab\cite{mlab}, oferującym darmowe rozwiązania wystarczające dla potrzeb tego projektu.

\chapter{Część inżynierska}
Cały system składa się z trzech głównych części:
\begin{itemize}
\item urządzenia lokalizującego
\item serwera API
\item aplikacji klienckich
\end{itemize}

W momencie wykrycia ruchu, urządzenie GPS łączy się z siecią Internet i rozpoczyna przesyłanie informacji o swojej lokalizacji na serwer. Wiadomości wysyłane są w równych interwałach. Serwer w momencie odebrania wiadomości uaktualnia bazę danych i w czasie rzeczywistym informuje aplikację kliencką o niepożądanym ruchu. Użytkownik ma możliwość podglądu obecnej pozycji urządzenia a także przeglądania historii wszystkich jego poprzednich aktywności.



\section{Urządzenie GPS}
Lokalizator to jeden z pierwszych komponentów, który powstał w ramach projektu. Schemat jego działania przedstawiony jest na poniższym diagramie:
\begin{figure}
\centering
\includegraphics[scale=0.5]{gps_flow.png}
\caption{Diagram działania lokalizatora GPS}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.7]{gps_polaczenia.png}
\caption{Schemat połączeń modułów elektrycznych}
\end{figure}

Urządzenie wykorzystuje bibliotekę \textit{Adafruit FONA} do obsługi modułu GSM. Udostępnia ona m.in. funkcje konfiguracji modułu, łączności z siecią i wysyłania zapytań HTTP przez GPRS

Po starcie urządzenia odbywa się wstępna konfiguracja połączeń serial port oraz modułu GSM - konfiguracja sieci oraz połączenia z internetem za pomocą GPRS. Następnie, w nieskończonej pętli sprawdzany jest aktualny tryb pracy i wykonywane odpowiednie działania związane z danym trybem. 

Zostały wydzielone cztery tryby: dwa główne, \textit{SLEEP} i \textit{TRACK} oraz dwa pomocnicze, \textit{ENTER\_SLEEP, ENTER\_TRACK}. Wyrażają one aktualny stan urządzania: w trybie \textit{SLEEP} lokalizator jest bezczynny, a w trybie \textit{TRACK} pracuje w trybie śledzenia pozycji, zbierając i wysyłając dane. Tryby pomocnicze występują, gdy obecny tryb główny ma zostać zmieniony na przeciwny. Wykonywane są w nich konfiguracje i reset zmiennych związanych z aktualnym stanem urządzania.

Wykrycie ruchu odbywa się poprzez przerwanie, które występuje w momencie zmiany napięcia na pinie INT1, do którego podłączony jest czujnik wstrząsów Waveshare. W momencie wystąpienia przerwania, działanie programu zostaje przekierowane na funkcję obsługującą przerwanie. W tym konkretnym przypadku, funkcja ta zmienia tryb pracy urządzenia na \textit{ENTER\_TRACK}. W tym trybie pobierana jest początkowa pozycja i czas wybudzania, dzięki któremu dana aktywność jest później możliwa do zgrupowania. 

W trybie śledzenia, program co iterację odczytuje dane GPS, wysyła je na serwer i sprawdza, czy urządzenie nie jest blisko położenia początkowego. Dane GPS odbierane są z modułu NEO-6M i przekazywane do instancji obiektu TinyGPS, który pochodzi z biblioteki o tej samej nazwie. Zdania NMEA są tam parsowane, a zwracane są potrzebne nam informacje: położenie geograficzne. Z zestawu danych w postaci identyfikatora urządzenia (kodu IMEI) oraz długości i szerokości geograficznej tworzony jest obiekt JSON, wysyłany przez HTTP na serwer API. Do pomiaru dystansu między punktami (początkowym a aktualnym) wykorzystywana jest \textit{Haversine formula}\cite{haversine}. 

Na potrzeby testów zaprojektowana została również obudowa na całe urządzenie w programie OpenSCAD. Końcowy projekt wyeksportowano do formatu stl akceptowanego przez drukarki 3D. Początkowo obudowa wykonana została z ABS. Ze względu na dobór zbyt małych luzów i technikę druku 3D materiałem ABS, wydruk uległ uszkodzeniu przy próbach poprawek. Kolejny wydruk, po poprawkach projektu, używał materiału /tu wstaw materiał/.



\section{Serwer API}
Serwer API pełni w projekcie kluczową rolę i jest jednocześnie uniwersalny dla każdego z pozostałych komponentów: łączą się z nim urządzenie GPS, aplikacja webowa oraz mobilna. Spełnia on następujące zadania:
\begin{itemize}
\item weryfikacja tożsamości użytkownika,
\item utrzymywanie sesji,
\item obsługa zapytań z aplikacji klienckich i urządzeń GPS,
\item modyfikacja rekordów w bazie danych,
\item tworzenie powiadomień dla aplikacji klienckich,
\item serwowanie aplikacji webowej.
\end{itemize}
Serwer nie kontroluje routingu aplikacji, którego role całkowicie przejęły aplikacje klienckie. Jego celem jest przede wszystkim zapewnienie przepływu danych i ich zapisu.

Uwierzytelnianie odbywa się przez tradycyjną parę e-mail i hasło. W momencie wysłania zapytania HTTP POST wraz z danymi użytkownika, serwer tworzy w bazie danych rekord użytkownika, hasło przetrzymywane jest w formie zahaszowanej, wzmocnione dodatkowo parametrem \textit{salt}.

Każde zapytanie przeznaczone dla zalogowanego użytkownika zabezpieczone jest przed wywołaniem przez nieautoryzowaną osobę. Wykorzystana jest do tego celu funkcjonalności frameworka Express.js: \textit{middleware} oraz sesja serwerowa. Dla każdego zapytania, nim zostanie przetworzone, sprawdzana jest tożsamość użytkownika. Ciasteczko wysyłane wraz z zapytaniem porównywane jest z danymi zapisanymi w sesji serwerowej, po czym następuje przyznanie lub odrzucenie dostępu do danych.

%tutaj diagram przedstawiający schemat działania middleware na przykładze isLoggedIn 

Serwer API eksponuje tzw. \textit{endpointy}, czyli punkty dostępowe pozwalające na kontakt z serwerem w celu modyfikacji lub pobrania danych. Każdy z endpointów dostępny jest pod konkretnym adresem URI i reaguje na odpowiednie zapytania HTTP: 
\begin{figure}
\centering
 \begin{tabular}{||c c c||} 
 \hline
 URN & Metoda HTTP & Opis \\ [0.5ex] 
 \hline\hline
 /user/login & POST & Logowanie użytkownika \\ 
 \hline
 /user/register & POST & Rejestracja użytkownika\\
 \hline
 /user/logout & POST & Zamknięcie sesji serwerowej\\
 \hline
 /user/user & GET & Pobranie danych użytkownika (wyłączając hash i salt)\\
 \hline
 /device/register & POST & Rejestracja urządzenia GPS  \\  
 \hline
  /device/updatelocation & POST & Uaktualnienie pozycji urządzenia GPS  \\  
 \hline
  /device/changename & POST & Zmiana wyświetlanej nazwy urządzenia \\  
 \hline
\end{tabular}
\caption{Tabela URI dostępnych w API}
\end{figure}



Każdy z URN API poprzedzony jest przez /api/v0 w celu odzielenia go od reszty aplikacji. 
Przykładowe URI pozwalające na logowanie:
\begin{figure}
\centering
\textit{https://gps-tracker.herokuapp.com/api/v0/user/login}
\end{figure}

Dane przesyłane między aplikacjami są w formacie JSON. Ze względu na to, że serwer napisany jest w EcmaScript, a aplikacje klienckie w TypeScript, pozwala to na wysyłanie i odczytywanie danych pozbawione parsowania. Mając instancję modelu lub interfejsu w formie obiektu, np. danego użytkownika, możliwe jest w takiej formie przesłanie go, odczytanie po stronie odbierającej i natychmiastowe operowanie na zmiennych.

W podobny sposób odbywają się operacje na bazie danych. MongoDB przechowuje dokumenty w postaci obiektów JSON, więc zapytania do bazy zwracają wyniki które natychmiast możemy przypisać do zmiennych i poddawać dalszym operacjom.

Model użytkownika w bazie danych przewiduje następującą strukturę:
\begin{lstlisting}{javascript}
{
    email: String,
    urzadzenia: [
        {
            type: Schema.Types.ObjectId,
            ref: 'Device'
        }
    ],
    dataUtworzenia: Date
};
\end{lstlisting}
Tablica urządzeń zarejestrowanych przez użytkownika to w rzeczywistości tablica ID obiektów znajdujących się w osobnej kolekcji. Zabieg ten ma na celu niezależny dostęp do użytkowników i urządzeń. Jest to powodowane tym, że urządzenie GPS nie przechowuje informacji do jakiego użytkownika jest zarejestrowane. Przy każdej aktualizacji lokalizacji przez urządzenia konieczne byłoby iterowanie po użytkownikach aż do odnalezienia właściciela. Takie zapytanie byłoby wolne i bardzo często występujące. Zastosowana struktura dokumentów niweluje ten problem.

\begin{lstlisting}{javascript}[extendedchars=false]
{
    IMEI: String,
    nazwa: String,
    daneGPS: [
        {
            czasObudzeniaGPS: String,
            tablicaLokalizacji: [
                {
                    szerokoscGeograficzna: Number,
                    dlugoscGeograficzna: Number,                    
                    data: Date
                }
            ]
        }
    ],

    dataUtworzenia: Date,
    wlasciciel: {
        type: Schema.Types.ObjectId,
        ref: 'User'
    }
}
\end{lstlisting}
Dokument urządzenia, poza danymi identyfikującymi, przechowuje przede wszystkim informacje o położeniu. W celu ułatwienia użytkownikowi przeglądania historii lokalizacji, zostały one podzielone na grupy identyfikowane przez \textit{czasObudzeniaGPS}, będący momentem w którym urządzenie GPS przeszło w stan aktywacji na skutek wykrycia ruchu. Jest to unikalny parametr, jednoznacznie identyfikujący aktywność.




\section{Aplikacja webowa}

\section{Aplikacja mobilna}


\chapter{Podsumowanie}

\addcontentsline{toc}{chapter}{Bibliografia}
\bibliography{bibliografia} 
%opcjonalnie może się tu pojawić spis rysunków i tabel
% \listoffigures
% \listoftables
\end{document}

